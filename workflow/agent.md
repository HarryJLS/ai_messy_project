# Agent - Antigravity 工作流

将 Claude Code 插件转换为 Antigravity 独立 Agent 工作流，保持相同的使用体验。

## 核心概念

| 文件/目录 | 用途 |
|----------|------|
| `features.json` | 任务的单一事实来源（任务定义、验收标准、状态） |
| `logs/` | 任务隔离日志目录 |
| `logs/init.log` | 初始化日志 |
| `logs/task-{id}.log` | 单个任务日志（每任务5阶段） |

**设计原则**：
- **抗遗忘**：通过读取相关任务日志恢复上下文
- **抗范围蔓延**：JSON 定义范围，日志提供详细上下文
- **可演进**：AI 可在执行前优化方案
- **隔离性**：每个任务的日志独立，便于精准检索
- **精准执行**：只改该改的，不碰不该碰的（宁可漏改，不可误改）
- **资深开发视角**：始终以资深开发的思维方式思考问题（Go/Java/Python/前端），考虑复用性、扩展性、健壮性

---

## 工作流 1: plan-init

**指令**: `/plan-init`

**描述**: 初始化 Agent 框架，创建状态文件

⚠️ **角色提醒**：整个初始化过程中，始终以**资深开发**的视角思考问题。根据项目技术栈（Go/Java/Python/前端）考虑：架构设计、代码复用、模块边界、异常处理、性能影响等。

### 协议

#### 步骤 1: 检查现有文件

检查项目根目录的 `features.json` 和 `logs/` 目录。

**如果 `features.json` 存在**，询问用户：

| 选项 | 行为 |
|------|------|
| 覆盖 | 备份到 `features.backup.{timestamp}.json`，创建新文件 |
| 追加 | 向现有数组添加新任务 |
| 合并 | 保留现有，仅添加非重复项 |
| 取消 | 中止初始化 → 停止 |

**如果 `logs/` 目录存在且有文件**，告知用户："发现现有日志，将保留它们。"

⛔ **门控**: 在用户选择选项前不得继续（针对 features.json）

#### 步骤 2: 创建文件

1. **创建 `features.json`**: `[]`（空数组）

2. **创建 `logs/` 目录**（如果不存在）: `mkdir -p logs`

3. **创建 `logs/init.log`** 并写入头部:
```
=== Agent 初始化日志 ===
初始化时间: [时间戳]
格式: 增强结构化格式（多段落日志）

日志类型参考:
- [Init] - 框架初始化（本文件）
- [Explore] - 代码库探索（在任务日志中）
- [Pending] - 任务规划（在任务日志中）
- [TDD-Red] - 红灯确认（在任务日志中）
- [TDD-Green] - 绿灯验证（在任务日志中）
- [Completed] - 任务完成（在任务日志中）
- [Fix/Refactor/Optimization/Design/Test/Docs/Config] - 手动日志

每个任务有独立日志文件: logs/task-{id}.log
---
```

4. **追加初始日志条目到 `logs/init.log`**:
```
[ISO 时间戳] [Init] Agent 框架设置
├─ Context: 用户初始化 Agent 进行结构化开发工作流
├─ Files: features.json（已创建）| logs/（目录已创建）| logs/init.log（本文件）
├─ Changes: 设置任务隔离日志架构
├─ Tech: JSON 用于任务存储 | 独立日志文件提升 token 效率
├─ Decision: 任务级日志隔离 → 更好的 token 管理，更易恢复上下文
└─ Result: 框架准备就绪，可定义项目目标和任务分解
---
```

#### 步骤 3: 获取项目目标

1. **询问用户**: "这个项目的核心目标是什么？"
2. ⛔ **等待用户响应** - 没有用户输入不得继续

3. **理解确认**（仅当从文档读取需求时）：

**触发条件**：用户提供了需求文档路径或让你读取 MD 文件

```
📋 我的理解：
- 要做什么：[复述核心目标]
- 要改什么：[具体改动点，精确到类/方法]
- 不改什么：[明确排除项]
- 边界条件：[特殊情况处理]

❓ 不确定的地方：[列出理解模糊的点，主动追问]

请确认是否正确，或指出理解偏差。
```

⚠️ **主动追问**：理解过程中有任何不清楚的地方，必须及时找用户确认，不要猜测

⛔ **门控**：用户确认理解正确后，才能继续

**如果用户直接描述需求**：跳过此步骤，直接进入需求澄清

4. **需求澄清**（资深开发视角）：

在分解任务前，根据需求类型选择追问：

| 类别 | 追问示例 |
|------|----------|
| 复用性 | 有没有现成的原子能力/工具类可以复用？ |
| 影响范围 | 这个改动会影响哪些模块？有没有上下游依赖？ |
| 边界 | 只改 A 还是 A 和 B 都改？有没有相似但不应该改的地方？ |
| 兼容性 | 需要向后兼容吗？老接口怎么处理？ |
| 异常处理 | 失败场景怎么处理？需要回滚机制吗？ |
| 性能考量 | 性能要求？是否需要缓存？批量处理？ |
| 测试策略 | 怎么验证改对了？怎么验证没改错？ |

⛔ **门控**：关键问题未澄清前，不得开始任务分解

5. 将用户响应分解为原子任务:

```json
{
  "id": "1",
  "category": "core|ui|feature|optimization",
  "description": "清晰的任务描述（做什么 + 为什么）",
  "steps": ["具体步骤1", "具体步骤2"],
  "acceptance": ["验收标准1：可验证的结果", "验收标准2"],
  "boundary": "可选：明确边界（只改什么，不改什么）",
  "test": "unit|integration|e2e|manual: 简述测试方法和关键用例",
  "passes": false
}
```

**字段说明**:
- `acceptance`: 2-4 个可验证的完成标准（必填）
- `boundary`: 任务边界（可选），明确"只改什么"和"不改什么"，防止误改
- `test`: 一句话说明测试方法（必填），格式：`方法: 关键测试点`

6. **向用户展示任务列表** 并请求确认
7. ⛔ **等待用户确认** 后再写入 features.json
8. **追加任务分解日志到 `logs/init.log`**

#### 步骤 4: 最终总结

追加最终初始化总结到 `logs/init.log`:
```
[ISO 时间戳] [Init] 初始化完成 - 准备执行
├─ Context: 框架设置完成，所有状态文件已创建
├─ Files: features.json（N 个任务）| logs/init.log（3 条日志）| logs/ 目录就绪
├─ Changes: 完成初始化 - 任务已定义，日志框架已设置
├─ Tech: 任务隔离日志架构 | 基于 JSON 的任务管理
├─ Decision: 所有任务初始 passes:false → 需验证后才能标记完成
└─ Result: 系统准备好执行 /plan-next | 所有 N 个任务待处理
---
```

### 完成后输出

```
✅ 初始化完成！

已创建:
• features.json - [N] 个任务就绪（全部 passes: false）
• logs/ - 任务隔离日志目录
• logs/init.log - [3] 条初始化日志已记录

日志架构:
→ 每个任务将获得 logs/task-{id}.log，包含5个详细阶段日志
→ Token 高效：只读取需要的日志
→ 无全局日志文件 - 完全隔离

下一步:
• 运行 /plan-next 开始第一个任务
```

⚠️ **告知用户后，停止并等待下一个命令。**

---

## 工作流 2: plan-next

**指令**: `/plan-next`

**描述**: 使用 Feature-Dev 工作流和 TDD 循环执行下一个待处理任务

⚠️ **角色提醒**：整个执行过程中，始终以**资深开发**的视角思考问题。根据项目技术栈（Go/Java/Python/前端）考虑：代码质量、边界情况、错误处理、性能优化、可维护性等。

### 关键规则

- **一次一个任务**，仅在验证后设置 `passes: true`
- **TDD 强制**：必须先看到 RED 再看 GREEN
- **日志用于恢复**：每条日志必须能在新会话中恢复上下文

### 日志格式（恢复优化）

每条日志必须回答：**"如果我在新会话中只读这条日志，能否继续？"**

```
[时间戳] [阶段] Task N: 一句话概述
├─ 状态: exploring|planning|red|green|blocked|done
├─ 决策: 关键决策（为什么这样做，避免重复决策）
├─ 文件: file1.ts, file2.ts（已改/将改）
├─ 问题: 遇到的问题 → 解决方案（或 none）
└─ 下一步: 具体下一步操作
---
```

### 阶段 1: READ

1. 读取 `features.json`，找到第一个 `passes: false`
2. 如果没有："所有任务已完成 🎉" → 停止
3. 宣布："开始任务 [ID]: [描述]"

### 阶段 2: EXPLORE（条件执行）

**仅当任务修改现有代码时执行**，新功能跳过。

判断标准：
- 修改现有功能 → 必须 Explore
- 全新功能 → 跳过，直接阶段 3

**执行时**：用文件搜索和阅读工具分析现有代码

**日志**:
```
[时间戳] [Explore] Task N: 分析 XXX 模块
├─ 状态: exploring → planning
├─ 决策: 发现 XXX 模式，计划复用/扩展
├─ 文件: existing1.ts, existing2.ts（将修改）
├─ 问题: none
└─ 下一步: 制定实现计划
---
```

### 阶段 3: PLAN

1. 查看任务的 `steps`, `acceptance`, `test`, `boundary` 字段
2. 如果模糊 → 先更新 features.json
3. **影响范围确认**（资深开发视角）：
   - 列出将要修改的文件/类/方法
   - 列出相似但**不应修改**的文件/类/方法
   - 如果有 `boundary` 字段，确认理解边界
4. 写日志

**日志**:
```
[时间戳] [Plan] Task N: 计划 XXX 功能
├─ 状态: planning → red
├─ 决策: 技术选型/架构决策要点
├─ 文件: new1.ts, new2.ts（将创建）| existing.ts（将修改）
├─ 问题: 预见的挑战 → 应对方案
└─ 下一步: 编写测试用例，确认 RED 状态
---
```

### 阶段 4: TDD RED 🔴

⚠️ **必须先看到测试失败，再写业务代码**

1. 根据任务 `test` 字段选择验证方式：
   - `unit/integration/e2e` → **调用 `/unit-test` 工作流**
   - `manual` → 写验证检查清单

2. **调用 `/unit-test` 工作流**（非 manual 类型时）：
   - `/unit-test` 会自动检测项目语言（Go/Java）
   - 根据项目现有测试风格生成测试代码
   - 完成后自动返回，继续 `plan-next` 后续阶段

3. 运行测试，**确认失败**

**日志**:
```
[时间戳] [Red] Task N: 测试准备完成
├─ 状态: red → implementing
├─ 决策: 选择 XXX 测试方式，因为 YYY
├─ 文件: test.spec.ts（已创建）
├─ 测试框架: [Go: Mockey+Testify | Java: Spock/JUnit]（由 /unit-test 检测）
├─ 问题: none
└─ 下一步: 实现功能代码，让测试通过
---
```

### 阶段 5: IMPLEMENT

- 写最小代码让测试通过
- 只做当前任务，不做额外"改进"
- **疑似确认**（防止误改）：
  - 如果发现相似但不确定是否要改的地方，**停下来列出**
  - 格式：`⚠️ 疑似需要修改：[位置] - [原因] - 请确认是否处理`
  - ⛔ **等待用户确认** 后再继续

### 阶段 6: GREEN 🟢

1. 运行测试 → 必须全部通过
2. 检查 `acceptance` 数组每项是否满足
3. **边界验证**（防止误改）：
   - 确认只修改了应该修改的内容
   - 确认没有误改相似但不相关的代码
4. 快速 self-check：
   - ✓ 边界：API 兼容？跨模块调用正常？
   - ✓ 健壮：错误处理？边界情况？
   - ✓ 精准：只改了该改的？没碰不该碰的？

**日志**:
```
[时间戳] [Green] Task N: 实现完成
├─ 状态: green → committing
├─ 决策: 实现要点/权衡取舍
├─ 文件: impl.ts, test.spec.ts（已完成）
├─ 问题: 遇到 XXX → 通过 YYY 解决（或 none）
└─ 下一步: 标记任务完成，提交
---
```

### 阶段 7: COMMIT

1. 设置 `passes: true` 在 features.json
2. 写最终日志

**日志**:
```
[时间戳] [Done] Task N: ✅ 完成
├─ 状态: done
├─ 决策: 关键架构决策总结（供后续任务参考）
├─ 文件: 所有变更文件列表
├─ 问题: 主要问题及解决方案总结
└─ 下一步: /plan-next 继续下一任务
---
```

### 成功标准

任务完成前必须满足：
1. ✅ 测试通过（RED → GREEN）
2. ✅ `acceptance` 全部满足
3. ✅ `passes: true` 已设置
4. ✅ `logs/task-{id}.log` 包含 3-4 条日志

### 恢复指南

**新会话恢复流程**：
```
1. 读 features.json → 找到当前任务
2. 读 logs/task-{id}.log 最后一条 → 查看"状态"和"下一步"
3. 从"下一步"继续执行
```

### 完成后输出

```
✅ 任务 [ID] 完成！

📄 日志: logs/task-{id}.log
→ 运行 /plan-next 继续下一任务
```

---

## 工作流 3: plan-log

**指令**: `/plan-log`

**描述**: 记录进度到任务特定日志文件

### 📂 日志文件架构

**任务级隔离**（token 高效设计）：
- `logs/task-{id}.log` - 每个任务有专属日志文件
- `logs/init.log` - 初始化日志（来自 /plan-init）
- `logs/manual-{YYYY-MM-DD}.log` - 手动日志

### ⚠️ 范围边界

此命令只记录进度。完成后：
- **停止**并等待用户下一个命令
- 不要自动运行其他命令

### 何时使用

⚠️ `/plan-next` **自动记录到 `logs/task-{id}.log`**（5 个阶段）
⚠️ `/plan-init` **自动记录到 `logs/init.log`**

**仅用于手动、非任务进度**（写入 `logs/manual-{date}.log`）：
- 架构/设计决策（非任务部分）
- 会议记录、技术评审
- 紧急 bug 修复（不在 features.json 中）
- 独立重构/优化（不在当前任务中）
- 配置/环境变更（不在当前任务中）

### 协议

#### 步骤 1: DIFF

- 检查 `git status` 或回忆最近的写入/编辑操作
- 如果没有代码变更：
  - 询问："有非代码进度吗？（设计决策、讨论）"
  - ⛔ **等待用户响应** - 没有输入不得继续

#### 步骤 2: SYNTHESIZE

生成包含三个元素的摘要：

| 元素 | 问题 |
|------|------|
| Context | 为什么这个变更？什么触发了它？ |
| Action | 修改了什么文件/函数？什么解决方案？ |
| Evaluation | 结果？目标达成？副作用？ |

#### 步骤 3: APPEND

**确定日志文件**：
- 如果为 features.json 中的特定任务记录 → `logs/task-{id}.log`
- 如果在初始化期间记录 → `logs/init.log`
- 如果手动记录（非任务相关）→ 创建 `logs/manual-{YYYY-MM-DD}.log`

追加到适当的日志文件，使用**增强结构化格式**：

```
[ISO 时间戳] [类型] Task [ID]: [一句话总结]
├─ Context: [为什么？背景？触发因素？]
├─ Files: [file1.js:func1,func2 | file2.js:ClassA | file3.css:line20-45]
├─ Changes: [做了什么？实现方法？]
│  └─ Code: [关键代码片段或伪代码（如相关）]
├─ Tech: [依赖: lib@ver | APIs: name | 模式: architecture]
├─ Decision: [为什么这种方法？备选: A,B,C → 选择: B → 原因: ...]
├─ Problems: [问题1 -> 方案1 | 问题2 -> 方案2]
└─ Result: [结果？目标达成？副作用？影响: 受影响的模块/文件]
---
```

### 日志类型

#### 自动生成（不要手动使用）
- `[Init]` - 框架初始化（由 /plan-init 自动记录）
- `[Explore]` - 代码库探索（由 /plan-next 阶段 2 自动记录）
- `[Pending]` - 任务规划（由 /plan-next 阶段 3 自动记录）
- `[TDD-Red]` - 红灯确认（由 /plan-next 阶段 4 自动记录）
- `[TDD-Green]` - 绿灯验证（由 /plan-next 阶段 6 自动记录）
- `[Completed]` - 任务完成（由 /plan-next 阶段 7 自动记录）

#### 手动日志类型（使用 /plan-log）
- `[Fix]` - 紧急 bug 修复（不在 features.json 中）
- `[Refactor]` - 独立重构
- `[Optimization]` - 性能改进
- `[Design]` - 架构/设计决策
- `[Test]` - 测试添加/修改
- `[Docs]` - 文档更新
- `[Config]` - 配置/环境变更

### 成功标准

全部必须为真：
1. ✅ 正确的日志文件已创建/更新
2. ✅ 条目使用增强结构化格式，包含所有相关部分
3. ✅ 时间戳和类型标签正确
4. ✅ 日志文件存储在 `logs/` 目录

---

## 工作流 4: plan-archive

**指令**: `/plan-archive`

**描述**: 归档已完成的功能、日志和相关文档

### ⚠️ 范围边界

此命令只处理归档。完成后：
- **停止**并等待用户下一个命令
- 不要自动运行其他命令

### 归档隔离原则

⚠️ **关键**：归档是只读快照，与活动工作流隔离：
- 活动工作流只使用根目录的 `./features.json` 和 `./logs/` 目录
- `archives/` 目录**永远不会**被 `plan-init`、`plan-next` 或 `plan-log` 扫描
- 恢复只能手动进行

### 何时使用

- 多个功能完成，想要重新开始
- 里程碑/冲刺结束
- `logs/` 目录有很多已完成的任务日志
- 开始新的开发阶段
- 项目迭代完成

### 归档结构

```
archives/YYYY-MM-DD-HHMMSS/
├── features.json
├── logs/
│   ├── init.log
│   ├── task-1.log
│   ├── task-2.log
│   └── task-N.log
├── ARCHIVE_INFO.md
└── docs/agents/*.md  (可选)
```

### 协议

#### 阶段 1: 分析

1. 检查根目录是否存在 `features.json`
2. 检查 `logs/` 目录是否存在且有日志文件
3. 统计 features.json 中的任务数
4. 统计 `logs/` 目录中的日志文件数（*.log 文件）
5. 扫描 `agents/` 目录中的文档文件（可选）
6. 显示简要摘要

⛔ **门控**：如果 features.json 和 logs/ 目录都不存在，停止并显示错误消息

#### 阶段 2: 创建归档

**默认行为（无需确认）**：

1. 创建 `archives/YYYY-MM-DD-HHMMSS/` 目录
2. 复制 `features.json` 到归档（如果存在）
3. 复制 `logs/` 目录到归档（如果存在）- 包含所有日志文件
4. 创建 `ARCHIVE_INFO.md`:
```markdown
# 归档: [ISO 时间戳]

## 摘要
- 归档任务: X 个总计（Y 个完成，Z 个待处理）
- 日志文件: N 个任务日志 + init.log
- 创建时间: [带时区的 ISO 时间戳]

## 归档的日志文件
- init.log - 初始化日志
- task-1.log - [任务 1 描述]
- task-2.log - [任务 2 描述]
- ... [列出所有任务日志]

## 文档
参见 docs/agents/（如适用）
```

⛔ **门控**：在继续阶段 3 之前验证归档创建成功

#### 阶段 3: 文档处理

**如果 `agents/` 目录存在且有 .md 文件**：

询问用户一个问题：
```
问题："在 agents/ 目录找到 N 个文档文件。归档它们吗？"
选项：
  - "是，移动到归档" → 移动 agents/*.md 到 archive/docs/agents/，删除原文件
  - "是，复制到归档" → 复制 agents/*.md 到 archive/docs/agents/，保留原文件
  - "否，跳过" → 不归档文档
```

⛔ **等待用户回答**，然后执行选定操作

**如果 `agents/` 目录不存在或为空**：

显示消息：
```
ℹ️ 在 agents/ 目录未找到文档文件。

如果你有相关文档：
1. 在项目根目录创建 agents/ 目录
2. 添加你的 .md 文件
3. 再次运行 /plan-archive 以包含它们
```

然后无需等待继续阶段 4。

#### 阶段 4: 清理和删除

⚠️ **关键安全检查**：删除任何原文件之前必须验证文件存在于归档中。

**验证步骤**：
1. 检查 `archives/[timestamp]/features.json` 存在且是有效 JSON（如果原文件存在）
2. 检查 `archives/[timestamp]/logs/` 目录存在（如果原目录存在）
3. 验证归档的 logs 目录与原目录有相同数量的 .log 文件
4. 检查 `archives/[timestamp]/ARCHIVE_INFO.md` 存在

**如果验证通过**：
1. **删除** 根目录的 `./features.json`（如果已归档）
2. **删除** 根目录的 `./logs/` 目录（如果已归档）- 移除所有任务日志
3. 如果用户选择"移动"文档：**删除** `./agents/*.md` 文件

**如果验证失败**：
- ❌ 立即停止
- 显示错误："归档验证失败。为安全起见，原文件未删除。"
- 保持所有原文件完整
- 显示验证失败的内容

⛔ **门控**：如果归档验证失败，绝不删除原文件

#### 阶段 5: 报告

显示完成摘要：
```
✅ 归档成功完成！

归档到: archives/[YYYY-MM-DD-HHMMSS]/
• features.json - X 个任务已归档（Y 个完成，Z 个待处理）
• logs/ 目录 - N 个日志文件已归档
  → init.log - 初始化日志
  → task-*.log - 单个任务日志（每任务完整5阶段历史）
• 文档 - [N 个文件已归档 / 跳过 / 未找到]

工作区已清理:
• 从根目录删除了 features.json
• 从根目录删除了 logs/ 目录（所有任务日志已移除）
• [已删除/保留] agents/ 文档

Token 节省:
→ 归档的日志不再在未来会话中消耗上下文
→ 新的 /plan-init 将从干净的日志结构开始
→ 旧项目保存在 archives/ 中供参考

下一步:
• 运行 /plan-init 开始新项目
• 或手动从 archives/ 恢复（如需要）：
  → 复制 archives/[timestamp]/features.json 到根目录
  → 复制 archives/[timestamp]/logs/ 到根目录
```

### 规则

- **自动**：无需确认 - 立即归档和删除
- **隔离**：命令只从根目录读取，永不从 `archives/` 读取
- **安全**：删除任何原文件前必须验证归档完整性
- **格式**：时间戳 `YYYY-MM-DD-HHMMSS` 用于按时间排序
- **完整性**：每个归档必须有 ARCHIVE_INFO.md 和至少一个：features.json 或 logs/ 目录
- **文档**：仅在 agents/ 文件存在时提示
- **清理**：成功归档后始终删除原始 features.json 和 logs/ 目录
- **日志保留**：归档整个 logs/ 目录，所有任务日志完整保留

### 成功标准

全部必须为真：
1. ✅ 归档目录已创建: `archives/YYYY-MM-DD-HHMMSS/`
2. ✅ `features.json` 已复制到归档（如果根目录存在）
3. ✅ `logs/` 目录已复制到归档，包含所有 .log 文件（如果根目录存在）
4. ✅ `ARCHIVE_INFO.md` 已创建，包含完整元数据
5. ✅ 归档完整性已验证（文件数匹配）
6. ✅ 原始 `features.json` 已从根目录**删除**（如果已归档）
7. ✅ 原始 `logs/` 目录已从根目录**删除**（如果已归档）
8. ✅ 文档按用户选择处理（如果存在）

---

## 使用指南

### 典型工作流

```
1. /plan-init      → 初始化项目，定义任务
2. /plan-next      → 执行任务（TDD 循环）
3. /plan-next      → 继续下一个任务
4. /plan-log       → 记录非任务进度（可选）
5. /plan-archive   → 里程碑完成，归档并重新开始
```

### 最佳实践

1. **保持任务原子性**：`features.json` 中的每个任务应该可以独立验证
2. **测试优先**：始终在实现之前创建验证机制
3. **一次一个任务**：在移动到下一个之前完成当前任务
4. **更新步骤**：如果需求变更，在编码之前更新任务 `steps`
5. **信任日志**：每任务的分阶段日志可完美恢复上下文
6. **归档里程碑**：使用 `/plan-archive` 清理工作区，开始新迭代

### 恢复中断的工作

新会话恢复流程：
1. 读取 `features.json` → 找到当前任务（第一个 `passes: false`）
2. 读取 `logs/task-{id}.log` 最后一条 → 查看"状态"和"下一步"
3. 从"下一步"继续执行

### 状态对应表

| 状态 | 含义 | 下一步 |
|------|------|--------|
| exploring | 正在分析 | 继续分析或进入 planning |
| planning | 正在规划 | 写测试，进入 red |
| red | 测试已写，待实现 | 写实现代码 |
| implementing | 正在实现 | 继续实现，然后测试 |
| green | 测试通过 | 检查 acceptance，提交 |
| blocked | 遇到阻塞 | 解决问题后继续 |
| done | 完成 | /plan-next |
