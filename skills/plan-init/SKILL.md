---
name: plan-init
description: 初始化 Agent Harness 框架，创建 features.json 状态文件和 logs/ 日志目录。当用户说 "/plan-init"、"初始化项目"、"开始新项目"、"创建任务列表"、"设置 Agent Harness" 时触发。用于启动新的结构化开发工作流。
---

# Plan Init

初始化 Agent Harness 框架，创建状态文件，并通过用户交互定义项目任务。

## 设计原则

- **抗遗忘**：通过读取相关任务日志恢复上下文
- **抗范围蔓延**：JSON 定义范围，日志提供详细上下文
- **可演进**：AI 可在执行前优化方案
- **隔离性**：每个任务的日志独立，便于精准检索
- **精准执行**：只改该改的，不碰不该碰的
- **资深开发视角**：考虑复用性、扩展性、健壮性

## 核心文件

| 文件/目录 | 用途 |
|----------|------|
| `features.json` | 任务的单一事实来源 |
| `logs/` | 任务隔离日志目录 |
| `logs/init.log` | 初始化日志 |
| `logs/task-{id}.log` | 单个任务日志 |

## 协议

### 步骤 1: 检查现有文件

检查项目根目录的 `features.json` 和 `logs/` 目录。

**如果 `features.json` 存在**，询问用户：

| 选项 | 行为 |
|------|------|
| 覆盖 | 备份到 `features.backup.{timestamp}.json`，创建新文件 |
| 追加 | 向现有数组添加新任务 |
| 合并 | 保留现有，仅添加非重复项 |
| 取消 | 中止初始化 |

**如果 `logs/` 目录存在且有文件**，告知用户："发现现有日志，将保留它们。"

⛔ **门控**: 在用户选择选项前不得继续

### 步骤 2: 创建文件

1. **创建 `features.json`**: `[]`（空数组）

2. **创建 `logs/` 目录**: `mkdir -p logs`

3. **创建 `logs/init.log`** 并写入头部:
```
=== Agent Harness 初始化日志 ===
初始化时间: [时间戳]
格式: 增强结构化格式

日志类型参考:
- [Init] - 框架初始化
- [Explore] - 代码库探索
- [Pending] - 任务规划
- [TDD-Red] - 红灯确认
- [TDD-Green] - 绿灯验证
- [Completed] - 任务完成
- [Fix/Refactor/Optimization/Design/Test/Docs/Config] - 手动日志

每个任务有独立日志文件: logs/task-{id}.log
---
```

4. **追加初始日志条目到 `logs/init.log`**:
```
[ISO 时间戳] [Init] Agent Harness 框架设置
├─ Context: 用户初始化 Agent Harness 进行结构化开发工作流
├─ Files: features.json（已创建）| logs/（目录已创建）| logs/init.log（本文件）
├─ Changes: 设置任务隔离日志架构
├─ Tech: JSON 用于任务存储 | 独立日志文件提升 token 效率
├─ Decision: 任务级日志隔离 → 更好的 token 管理，更易恢复上下文
└─ Result: 框架准备就绪，可定义项目目标和任务分解
---
```

### 步骤 3: 获取项目目标

1. **询问用户**: "这个项目的核心目标是什么？"
2. ⛔ **等待用户响应**

3. **理解确认**（仅当从文档读取需求时）：

**触发条件**：用户提供了需求文档路径或让你读取 MD 文件

```
📋 我的理解：
- 要做什么：[复述核心目标]
- 要改什么：[具体改动点，精确到类/方法]
- 不改什么：[明确排除项]
- 边界条件：[特殊情况处理]

❓ 不确定的地方：[列出理解模糊的点，主动追问]

请确认是否正确，或指出理解偏差。
```

⛔ **门控**：用户确认理解正确后，才能继续

4. **需求澄清**（资深开发视角）：

| 类别 | 追问示例 |
|------|----------|
| 复用性 | 有没有现成的原子能力/工具类可以复用？ |
| 影响范围 | 这个改动会影响哪些模块？有没有上下游依赖？ |
| 边界 | 只改 A 还是 A 和 B 都改？ |
| 兼容性 | 需要向后兼容吗？老接口怎么处理？ |
| 异常处理 | 失败场景怎么处理？ |
| 性能考量 | 性能要求？是否需要缓存？ |
| 测试策略 | 怎么验证改对了？怎么验证没改错？ |

⛔ **门控**：关键问题未澄清前，不得开始任务分解

5. 将用户响应分解为原子任务:

```json
{
  "id": "1",
  "category": "core|ui|feature|optimization",
  "description": "清晰的任务描述（做什么 + 为什么）",
  "steps": ["具体步骤1", "具体步骤2"],
  "acceptance": ["验收标准1：可验证的结果", "验收标准2"],
  "boundary": "可选：明确边界（只改什么，不改什么）",
  "test": "unit|integration|e2e|manual: 简述测试方法和关键用例",
  "passes": false
}
```

6. **向用户展示任务列表** 并请求确认
7. ⛔ **等待用户确认** 后再写入 features.json
8. **追加任务分解日志到 `logs/init.log`**

### 步骤 4: 最终总结

追加最终初始化总结到 `logs/init.log`:
```
[ISO 时间戳] [Init] 初始化完成 - 准备执行
├─ Context: 框架设置完成，所有状态文件已创建
├─ Files: features.json（N 个任务）| logs/init.log（3 条日志）| logs/ 目录就绪
├─ Changes: 完成初始化 - 任务已定义，日志框架已设置
├─ Tech: 任务隔离日志架构 | 基于 JSON 的任务管理
├─ Decision: 所有任务初始 passes:false → 需验证后才能标记完成
└─ Result: 系统准备好执行 /plan-next | 所有 N 个任务待处理
---
```

## 完成后输出

```
✅ 初始化完成！

已创建:
• features.json - [N] 个任务就绪（全部 passes: false）
• logs/ - 任务隔离日志目录
• logs/init.log - [3] 条初始化日志已记录

日志架构:
→ 每个任务将获得 logs/task-{id}.log，包含5个详细阶段日志
→ Token 高效：只读取需要的日志
→ 无全局日志文件 - 完全隔离

下一步:
• 运行 /plan-next 开始第一个任务
```

⚠️ **告知用户后，停止并等待下一个命令。**
